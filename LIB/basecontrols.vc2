*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="basecontrols.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS basecheckbox AS checkbox 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: lupdatecontrolsourceonchange		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Alignment = 0
	AutoSize = .T.
	BackStyle = 0
	Caption = "Check1"
	FontName = "Tahoma"
	FontSize = 8
	lupdatecontrolsourceonchange = .F.		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
	Name = "basecheckbox"
	Value = .F.
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="lupdatecontrolsourceonchange" type="property" display="lUpdateControlSourceOnChange" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method
		
	ENDPROC

	PROCEDURE InteractiveChange
		local lcAlias, ;
			lcField
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case not .lUpdateControlSourceOnChange or empty(.ControlSource) or ;
					.Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		local lcAlias, ;
			lcField
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case not .lUpdateControlSourceOnChange or empty(.ControlSource) or ;
					.Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecollection AS collection 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Height = 23
	Name = "buildercollection"
	Width = 23
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS basecombobox AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*a: aitems[1,0]		&& An array of items for the RowSource if RowSourceType is set to 5-Array
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	Height = 22
	ItemTips = .T.
	Name = "basecombobox"
	Style = 2
	_memberdata = <VFPData>
		<memberdata name="aitems" type="property" display="aItems"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE DropDown
		* Set DisplayCount to an appropriate value based on how much room there is
		* below the form.
		
		local lnHeight
		lnHeight = iif(Thisform.ShowWindow = 2, sysmetric(2), _vfp.Height)
		This.DisplayCount = max(ceiling((lnHeight - Thisform.Top - ;
			objtoclient(This, 1))/This.Height), 7)
		
	ENDPROC

	PROCEDURE Init
		* Initialize aItems.
		
		This.aItems = ''
		
	ENDPROC

	PROCEDURE InteractiveChange
		local lcAlias, ;
			lcField
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case empty(.ControlSource) or .Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		local lcAlias, ;
			lcField
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case empty(.ControlSource) or .Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecommandbutton AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Command1"
	FontName = "Tahoma"
	FontSize = 8
	Height = 23
	Name = "basecommandbutton"
	Width = 75
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS basecontainer AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: enabled_assign
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Name = "basecontainer"
	Style = 3
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE enabled_assign
		lparameters tlEnabled
		This.Enabled = tlEnabled
		This.SetAll('Enabled', tlEnabled)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseeditbox AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: validation		&& Custom validation code
		*p: lupdatecontrolsourceonchange		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	IntegralHeight = .T.
	lupdatecontrolsourceonchange = .F.		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
	Name = "baseeditbox"
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="lupdatecontrolsourceonchange" type="property" display="lUpdateControlSourceOnChange" favorites="True"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), call
		* the AnyChange method, and restore the current cursor position in case
		* This.Refresh got called from AnyChange.
		
		local lnSelStart, ;
			lcAlias, ;
			lcField
		with This
			lnSelStart = .SelStart
			lcAlias    = juststem(.ControlSource)
			lcField    = justext(.ControlSource)
			do case
				case not .lUpdateControlSourceOnChange or empty(.ControlSource) or ;
					.Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
			.SelStart = lnSelStart
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		local lcAlias, ;
			lcField
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case not .lUpdateControlSourceOnChange or empty(.ControlSource) or ;
					.Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE Valid
		* If we're not canceling, call the Validation method to do the actual
		* validation.
		
		local luReturn
		with This
			if lastkey() <> 27
				luReturn = .Validation()
			else
				luReturn = .T.
			endif lastkey() <> 27
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE validation		&& Custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE When
		* Store the current value into the Tag property so it can be restored if Valid
		* fails.
		
		This.Tag = This.Value
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: cleanup		&& Cleans up references when the form is closed
		*m: refreshform		&& Refreshes the form with the LockScreen .T.
		*m: releasemembers		&& Releases member objects
		*m: restoresettings		&& Restores saved settings from FOXUSER
		*m: savesettings		&& Saves settings to FOXUSER
		*p: cfoxuserid		&& The FOXUSER ID to save/restore settings to
		*p: cfoxusername		&& The FOXUSER NAME to save/restore settings to
		*p: lpersistsizeposition		&& .T. to persist the size and position of the form
		*p: lrelease		&& .T. if the form is being released
		*p: lsavesettings		&& .T. to save and restore settings
		*p: opersist		&& A reference to a FoxResource object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	AllowOutput = .F.
	AutoCenter = .T.
	Caption = "Form"
	cfoxuserid = 		&& The FOXUSER ID to save/restore settings to
	cfoxusername = 		&& The FOXUSER NAME to save/restore settings to
	DataSession = 2
	DoCreate = .T.
	FontName = "Tahoma"
	FontSize = 8
	lpersistsizeposition = .T.		&& .T. to persist the size and position of the form
	lrelease = .F.		&& .T. if the form is being released
	lsavesettings = .T.		&& .T. to save and restore settings
	Name = "baseform"
	opersist = .NULL.		&& A reference to a FoxResource object
	ShowTips = .T.
	_memberdata = <VFPData>
		<memberdata name="cfoxuserid" type="property" display="cFoxUserID" favorites="True"/>
		<memberdata name="cfoxusername" type="property" display="cFoxUserName" favorites="True"/>
		<memberdata name="lpersistsizeposition" type="property" display="lPersistSizePosition" favorites="True"/>
		<memberdata name="lsavesettings" type="property" display="lSaveSettings" favorites="True"/>
		<memberdata name="opersist" type="property" display="oPersist"/>
		<memberdata name="refreshform" type="method" display="RefreshForm"/>
		<memberdata name="restoresettings" type="method" display="RestoreSettings" favorites="True"/>
		<memberdata name="savesettings" type="method" display="SaveSettings" favorites="True"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROTECTED PROCEDURE cleanup		&& Cleans up references when the form is closed
		* Clean up references when the form is closed.
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE Destroy
		with This
		
		* Hide the form so it appears to go away faster.
		
			.Hide()
		
		* Cleanup as the object is destroyed.
		
			.Cleanup()
		
		* Save the current settings
		
			if .lSaveSettings
				.SaveSettings()
			endif .lSaveSettings
		
		* Nuke member objects.
		
			.oPersist = .NULL.
		endwith
		
	ENDPROC

	PROCEDURE Init
		local lcLibrary
		with This
		
		* Restore saved options and the size and position of the form.
		
			if .lSaveSettings
				lcLibrary = 'FoxResource.prg'
				.oPersist = newobject('FoxResource', lcLibrary)
				.RestoreSettings()
			endif .lSaveSettings
		endwith
		
	ENDPROC

	PROCEDURE Load
		* Set some environmental things the way we want if we're in a private
		* datasession. These are in alphabetical order. Not all are datasession-
		* specific, but we'll set 'em anyway.
		
		if This.DataSession = 2
			set ansi       off
			set compatible off			&& not datasession-specific
			set cpdialog   off			&& not datasession-specific
			set deleted    on
			set exact      off
			set exclusive  off
			set multilocks on
			set near       off
			set safety     off
			set talk       off
			set unique     off
			sys(3054, 0)
		
		* Set CENTURY after SYSFORMATS, since SYSFORMATS changes CENTURY.
		
			set sysformats on
			set century    on
		endif This.DataSession = 2
		
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form with the LockScreen .T.
		* Lock for form while refreshing.
		
		This.LockScreen = .T.
		This.Refresh()
		This.LockScreen = .F.
		
	ENDPROC

	PROCEDURE Release
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		
	ENDPROC

	PROTECTED PROCEDURE releasemembers		&& Releases member objects
		* Abstract method.
		
	ENDPROC

	PROCEDURE restoresettings		&& Restores saved settings from FOXUSER
		* Restore saved settings from FOXUSER.
		
		with This
			.oPersist.Load(.cFoxUserID, .cFoxUserName)
			if .lPersistSizePosition
				.Top    = max(nvl(.oPersist.Get('Top'),  .Top),  0)
				.Left   = max(nvl(.oPersist.Get('Left'), .Left), 0)
				.Height = nvl(.oPersist.Get('Height'),   .Height)
				.Width  = nvl(.oPersist.Get('Width'),    .Width)
			endif .lPersistSizePosition
		endwith
		
	ENDPROC

	PROCEDURE savesettings		&& Saves settings to FOXUSER
		* Save settings to FOXUSER.
		
		with This
			if .lPersistSizePosition
				.oPersist.Set('Top',    .Top)
				.oPersist.Set('Left',   .Left)
				.oPersist.Set('Height', .Height)
				.oPersist.Set('Width',  .Width)
			endif .lPersistSizePosition
			.oPersist.Save(.cFoxUserID, .cFoxUserName)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basegrid AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	FontName = "Tahoma"
	FontSize = 8
	Height = 200
	Name = "basegrid"
	RowHeight = 16
	Width = 320

ENDDEFINE

DEFINE CLASS baseimage AS image 
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackStyle = 0
	Height = 17
	Name = "baseimage"
	Width = 100

ENDDEFINE

DEFINE CLASS baselabel AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AutoSize = .T.
	BackStyle = 0
	Caption = "Label1"
	FontName = "Tahoma"
	FontSize = 8
	Name = "baselabel"
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS baselabelledbox AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpBox" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBox" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: height_assign
		*m: width_assign
		*p: builder		&& Specifies the builder for this object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	builder = BaseLabelledBoxBuilder.PRG		&& Specifies the builder for this object
	Height = 133
	Name = "baselabelledbox"
	Style = 3
	Width = 168
	_memberdata = <VFPData>
		<memberdata name="builder" type="property" display="Builder"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'lblBox' AS baselabel WITH ;
		BackStyle = 1, ;
		Left = 10, ;
		Name = "lblBox", ;
		Style = 3
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'shpBox' AS baseline3d WITH ;
		Height = 124, ;
		Name = "shpBox", ;
		Top = 7, ;
		Width = 166
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="shape" />
	
	PROCEDURE height_assign
		* When the height of the container is resized, resize the shape.
		
		lparameters tnHeight
		This.Height = tnHeight
		This.shpBox.Height = tnHeight - This.shpBox.Top
		
	ENDPROC

	PROCEDURE width_assign
		* When the width of the container is resized, resize the shape.
		
		lparameters tnWidth
		store tnWidth to This.Width, This.shpBox.Width
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseline3d AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackStyle = 0
	Height = 1
	Name = "baseline3d"
	SpecialEffect = 0
	Style = 3
	Width = 100
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS baselistbox AS listbox 
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	IntegralHeight = .T.
	ItemTips = .T.
	Name = "baselistbox"
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		local lcAlias, ;
			lcField
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case empty(.ControlSource) or .Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		local lcAlias, ;
			lcField
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case empty(.ControlSource) or .Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseoptionbutton AS optionbutton 
 	*< CLASSDATA: Baseclass="optionbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AutoSize = .T.
	BackStyle = 0
	Caption = "Option1"
	FontName = "Tahoma"
	FontSize = 8
	Name = "baseoptionbutton"
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseoptiongroup AS optiongroup 
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: enabled_assign		&& Enable/disabled member objects
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderStyle = 0
	ButtonCount = 2
	Height = 46
	MemberClass = "baseoptionbutton"
	MemberClassLibrary = basecontrols.vcx
	Name = "baseoptiongroup"
	Value = 0
	Width = 71
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		</VFPData>		&& XML Metadata for customizable properties
	Baseoptionbutton1.Left = 5
	Baseoptionbutton1.Name = "Baseoptionbutton1"
	Baseoptionbutton1.Top = 5
	Baseoptionbutton2.Left = 5
	Baseoptionbutton2.Name = "Baseoptionbutton2"
	Baseoptionbutton2.Top = 23
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE enabled_assign		&& Enable/disabled member objects
		* Enable or disable member objects.
		
		lparameters tlEnabled
		This.SetAll('Enabled', tlEnabled)
		This.Enabled = tlEnabled
		
	ENDPROC

	PROCEDURE InteractiveChange
		local lcAlias, ;
			lcField
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case empty(.ControlSource) or .Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		local lcAlias, ;
			lcField
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case empty(.ControlSource) or .Value == evaluate(.ControlSource)
				case used(lcAlias)
					replace &lcField with .Value in (lcAlias)
				otherwise
					store .Value to (.ControlSource)
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basepage AS page 
 	*< CLASSDATA: Baseclass="page" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Page1"
	FontName = "Tahoma"
	FontSize = 8
	Height = 142
	Name = "basepage"
	Width = 142
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Activate
		* Refresh all controls.
		
		local llLockScreen
		with This
			llLockScreen = Thisform.LockScreen
			if not llLockScreen
				Thisform.LockScreen = .T.
			endif not llLockScreen
			.Refresh()
			if not llLockScreen
				Thisform.LockScreen = .F.
			endif not llLockScreen
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basepageframe AS pageframe 
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: getpagenumber		&& Gets the page number in the Pages collection that matches the specified page order
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	ErasePage = .T.
	Height = 250
	MemberClass = "basepage"
	MemberClassLibrary = basecontrols.vcx
	Name = "basepageframe"
	PageCount = 1
	TabStyle = 1
	_memberdata = <VFPData>
		<memberdata name="getpagenumber" type="method" display="GetPageNumber"/>
		</VFPData>		&& XML Metadata for customizable properties
	Basepage1.Name = "Basepage1"
	
	PROCEDURE getpagenumber		&& Gets the page number in the Pages collection that matches the specified page order
		* Gets the page number in the Pages collection that matches the specified page
		* order. These values won't be the same if the PageOrder property for any page
		* has been changed.
		
		lparameters tnActivePage
		local lnPage, ;
			lnI
		with This
			lnPage = 0
			for lnI = 1 to .PageCount
				if .Pages[lnI].PageOrder = tnActivePage
					lnPage = lnI
					exit
				endif .Pages[lnI].PageOrder = tnActivePage
			next lnI
		endwith
		return lnPage
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseshape AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackStyle = 0
	Height = 17
	Name = "baseshape"
	Width = 100

ENDDEFINE

DEFINE CLASS basespinner AS spinner 
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	Height = 22
	Name = "basespinner"
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		do case
		
		* Spinners bound to object properties seem to have a problem when invalid
		* values are entered from the keyboard: the Error method fires with error 1469
		* (property value is out of bounds) with tcMethod being "ControlSource" rather
		* than the Valid method catching it.
		
			case tnError = 1469
				return
		
		* Ignore "property is read-only" errors.
		
			case tnError = 1743
				return
		
		* All other errors get passed on to the form.
		
			otherwise
				Thisform.Error(tnError, This.Name + '.' + tcMethod, tnLine)
		endcase
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), call
		* the AnyChange method, and restore the current cursor position in case
		* This.Refresh got called from AnyChange. Note: if the value is invalid, don't
		* do anything.
		
		local lnSelStart, ;
			lcAlias, ;
			lcField
		if not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
			nodefault
			return
		endif not between(This.Value, ...
		with This
			lnSelStart = .SelStart
			lcAlias    = juststem(.ControlSource)
			lcField    = justext(.ControlSource)
			do case
				case empty(.ControlSource) or .Value == evaluate(.ControlSource)
				case used(lcAlias)
					try
						replace &lcField with .Value in (lcAlias)
					catch
						nodefault
					endtry
				otherwise
					try
						store .Value to (.ControlSource)
					catch
						nodefault
					endtry
			endcase
			.AnyChange()
			.SelStart = lnSelStart
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource) and
		* call the AnyChange method. Note: if the value is invalid, don't do anything.
		
		local lcAlias, ;
			lcField
		if not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
			nodefault
			return
		endif not between(This.Value, ...
		with This
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case empty(.ControlSource) or .Value == evaluate(.ControlSource)
				case used(lcAlias)
					try
						replace &lcField with .Value in (lcAlias)
					catch
						nodefault
					endtry
				otherwise
					try
						store .Value to (.ControlSource)
					catch
						nodefault
					endtry
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basetextbox AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: validation		&& Custom validation code
		*p: lupdatecontrolsourceonchange		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	Format = "T"
	Height = 22
	lupdatecontrolsourceonchange = .F.		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
	Name = "basetextbox"
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="lupdatecontrolsourceonchange" type="property" display="lUpdateControlSourceOnChange" favorites="True"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), being
		* sure to trim it if it's a character, then call the AnyChange method, and
		* restore the current cursor position in case This.Refresh got called from
		* AnyChange.
		
		local lnSelStart, ;
			luValue, ;
			lcAlias, ;
			lcField
		with This
			lnSelStart = .SelStart
			luValue    = iif(vartype(.Value) = 'C', trim(.Value), .Value)
			lcAlias    = juststem(.ControlSource)
			lcField    = justext(.ControlSource)
			do case
				case not .lUpdateControlSourceOnChange or empty(.ControlSource) or ;
					.Value == evaluate(.ControlSource)
				case used(lcAlias)
					try
						replace &lcField with .Value in (lcAlias)
					catch
						nodefault
					endtry
				otherwise
					try
						store .Value to (.ControlSource)
					catch
						nodefault
					endtry
			endcase
			.AnyChange()
			.SelStart = lnSelStart
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), being
		* sure to trim it if it's a character, then call the AnyChange method.
		
		local luValue, ;
			lcAlias, ;
			lcField
		with This
			luValue = iif(vartype(.Value) = 'C', trim(.Value), .Value)
			lcAlias = juststem(.ControlSource)
			lcField = justext(.ControlSource)
			do case
				case not .lUpdateControlSourceOnChange or empty(.ControlSource) or ;
					.Value == evaluate(.ControlSource)
				case used(lcAlias)
					try
						replace &lcField with .Value in (lcAlias)
					catch
						nodefault
					endtry
				otherwise
					try
						store .Value to (.ControlSource)
					catch
						nodefault
					endtry
			endcase
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE Valid
		* If we're not canceling, call the Validation method to do the actual
		* validation.
		
		local luReturn
		with This
			if lastkey() <> 27
				luReturn = .Validation()
			else
				luReturn = .T.
			endif lastkey() <> 27
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE validation		&& Custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE When
		* Store the current value into the Tag property so it can be restored if Valid
		* fails.
		
		This.Tag = This.Value
		
	ENDPROC

ENDDEFINE
