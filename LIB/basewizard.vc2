*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="basewizard.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS basewizardcheckbox AS basecheckbox OF "basecontrols.vcx" 		&& Base class for Wizard CheckBox objects
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refreshsteps		&& Refreshes the wizard form
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	*</DefinedPropArrayMethod>

	Alignment = 0
	lrefreshsteps = .T.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	Name = "basewizardcheckbox"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps" favorites="True"/>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		</VFPData>
	
	PROCEDURE InteractiveChange
		dodefault()
		This.RefreshSteps()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		dodefault()
		This.RefreshSteps()
		
	ENDPROC

	PROTECTED PROCEDURE refreshsteps		&& Refreshes the wizard form
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if .lRefreshSteps and lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif .lRefreshSteps ...
		endwith
		if pemstatus(Thisform, 'RefreshSteps', 5)
			Thisform.RefreshSteps()
		else
			Thisform.RefreshForm()
		endif pemstatus(Thisform, 'RefreshSteps', 5)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basewizardcombobox AS basecombobox OF "basecontrols.vcx" 		&& Base class for Wizard ComboBox objects
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refreshsteps		&& Refreshes the wizard form
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
		*p: lrefreshstepsonchange		&& .T. to refresh the Wizard steps when the value is changed
	*</DefinedPropArrayMethod>

	lrefreshsteps = .T.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	lrefreshstepsonchange = .T.		&& .T. to refresh the Wizard steps when the value is changed
	Name = "sfwizardcombobox"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps" favorites="True"/>
		<memberdata name="lrefreshstepsonchange" type="property" display="lRefreshStepsOnChange" favorites="True"/>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		</VFPData>
	
	PROCEDURE InteractiveChange
		dodefault()
		with This
			if .lRefreshStepsOnChange
				.RefreshSteps()
			endif .lRefreshStepsOnChange
		endwith
		
	ENDPROC

	PROCEDURE LostFocus
		* Call This.RefreshSteps if we didn't already.
		
		if not This.lRefreshStepsOnChange
			This.RefreshSteps()
		endif not This.lRefreshStepsOnChange
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		dodefault()
		This.RefreshSteps()
		
	ENDPROC

	PROTECTED PROCEDURE refreshsteps		&& Refreshes the wizard form
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if .lRefreshSteps and lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif .lRefreshSteps ...
		endwith
		if pemstatus(Thisform, 'RefreshSteps', 5)
			Thisform.RefreshSteps()
		else
			Thisform.RefreshForm()
		endif pemstatus(Thisform, 'RefreshSteps', 5)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basewizardcommandbutton AS basecommandbutton OF "basecontrols.vcx" 		&& Base class for Wizard CommandButton objects
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	*</DefinedPropArrayMethod>

	lrefreshsteps = .T.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	Name = "sfwizardcommandbutton"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps" favorites="True"/>
		</VFPData>

ENDDEFINE

DEFINE CLASS basewizardcontainer AS basecontainer OF "basecontrols.vcx" 		&& Base class for Wizard Container objects
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	*</DefinedPropArrayMethod>

	lrefreshsteps = .T.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	Name = "sfwizardcontainer"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps"/>
		</VFPData>

ENDDEFINE

DEFINE CLASS basewizardeditbox AS baseeditbox OF "basecontrols.vcx" 		&& Base class for Wizard EditBox objects
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refreshsteps		&& Refreshes the wizard form
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
		*p: lrefreshstepsonchange		&& .T. to refresh the Wizard steps when the value is changed
	*</DefinedPropArrayMethod>

	lrefreshsteps = .T.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	lrefreshstepsonchange = .T.		&& .T. to refresh the Wizard steps when the value is changed
	Name = "sfwizardeditbox"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps" favorites="True"/>
		<memberdata name="lrefreshstepsonchange" type="property" display="lRefreshStepsOnChange" favorites="True"/>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		</VFPData>
	
	PROCEDURE InteractiveChange
		dodefault()
		with This
			if .lRefreshStepsOnChange
				.RefreshSteps()
			endif .lRefreshStepsOnChange
		endwith
		
	ENDPROC

	PROCEDURE LostFocus
		* Call This.RefreshSteps if we didn't already.
		
		if not This.lRefreshStepsOnChange
			This.RefreshSteps()
		endif not This.lRefreshStepsOnChange
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		dodefault()
		This.RefreshSteps()
		
	ENDPROC

	PROCEDURE refreshsteps		&& Refreshes the wizard form
		local lnPos, ;
			lnStart, ;
			lcAlias, ;
			lcField
		with This
			lnPos   = at('.', .ControlSource)
			lnStart = .SelStart
			if .lRefreshSteps and lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif .lRefreshSteps ...
		endwith
		if pemstatus(Thisform, 'RefreshSteps', 5)
			Thisform.RefreshSteps()
		else
			Thisform.RefreshForm()
		endif pemstatus(Thisform, 'RefreshSteps', 5)
		This.SelStart = lnStart
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basewizardform AS baseform OF "basecontrols.vcx" 		&& Base class for Wizard forms
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="pgfWizard" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBack" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNext" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFinish" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboSteps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="shpSeparator" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cancel		&& Reverts in all open work areas
		*m: finish		&& An abstract method to do the "finish" tasks
		*m: isstepenabled		&& Determines if a step is enabled
		*m: loadstepscombo		&& Loads the Steps combobox
		*m: refreshsteps		&& Set the "step complete" flags in the aSteps array
		*m: restorehelp		&& Restores the save help setting and file
		*m: save		&& Saves in all open work areas
		*m: selectstep		&& Select a particular step
		*m: sethelp		&& Sets up the help system
		*m: setupsteps		&& Abstract method to initialize the aSteps array
		*m: stepdone		&& Abstract method called when a step is complete
		*m: stepselected		&& Abstract method called when a step is selected
		*m: validatecurrentcontrol		&& Ensures the current control's value is valid
		*p: ccurrhelp		&& The saved HELP setting
		*p: ccurrhelpfile		&& The saved HELP file
		*p: chelpfile		&& The name of the help file for this wizard
		*p: cregistrykey		&& The Registry key where settings should saved
		*p: lcancel		&& .T. if Cancel was chosen
		*p: lfinish		&& .T. if Finish was chosen
		*p: ncurrentstep		&& The current step
		*p: nformerstep		&& The formerly selected step
		*p: nmaxsteps		&& The number of steps in the wizard
		*a: asteps[1,0]		&& An array of steps; see About for documentation
	*</DefinedPropArrayMethod>

	PROTECTED ccurrhelp,ccurrhelpfile
	BufferMode = 2
	Caption = "Wizard"
	ccurrhelp = 		&& The saved HELP setting
	ccurrhelpfile = 		&& The saved HELP file
	chelpfile = 		&& The name of the help file for this wizard
	Closable = .F.
	cregistrykey = 		&& The Registry key where settings should saved
	DataSession = 2
	DoCreate = .T.
	Height = 364
	lcancel = .F.		&& .T. if Cancel was chosen
	lfinish = .F.		&& .T. if Finish was chosen
	Name = "basewizardform"
	ncurrentstep = 0		&& The current step
	nformerstep = 0		&& The formerly selected step
	nmaxsteps = 0		&& The number of steps in the wizard
	Width = 536
	_memberdata = <VFPData>
		<memberdata name="asteps" type="property" display="aSteps"/>
		<memberdata name="ccurrhelp" type="property" display="cCurrHelp"/>
		<memberdata name="ccurrhelpfile" type="property" display="cCurrHelpFile"/>
		<memberdata name="chelpfile" type="property" display="cHelpFile" favorites="True"/>
		<memberdata name="finish" type="method" display="Finish" favorites="True"/>
		<memberdata name="isstepenabled" type="method" display="IsStepEnabled"/>
		<memberdata name="lcancel" type="property" display="lCancel"/>
		<memberdata name="lfinish" type="property" display="lFinish"/>
		<memberdata name="loadstepscombo" type="method" display="LoadStepsCombo"/>
		<memberdata name="ncurrentstep" type="property" display="nCurrentStep"/>
		<memberdata name="nformerstep" type="property" display="nFormerStep"/>
		<memberdata name="nmaxsteps" type="property" display="nMaxSteps" favorites="True"/>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		<memberdata name="restorehelp" type="method" display="RestoreHelp"/>
		<memberdata name="save" type="method" display="Save"/>
		<memberdata name="selectstep" type="method" display="SelectStep"/>
		<memberdata name="sethelp" type="method" display="SetHelp"/>
		<memberdata name="setupsteps" type="method" display="SetupSteps" favorites="True"/>
		<memberdata name="stepdone" type="method" display="StepDone" favorites="True"/>
		<memberdata name="stepselected" type="method" display="StepSelected"/>
		<memberdata name="validatecurrentcontrol" type="method" display="ValidateCurrentControl"/>
		<memberdata name="cancel" type="method" display="Cancel"/>
		<memberdata name="cregistrykey" type="property" display="cRegistryKey"/>
		</VFPData>

	ADD OBJECT 'cboSteps' AS basecombobox WITH ;
		BoundTo = .F., ;
		Left = 205, ;
		Name = "cboSteps", ;
		RowSource = "", ;
		RowSourceType = 1, ;
		TabIndex = 2, ;
		Top = 20, ;
		Value = 0, ;
		Width = 304
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdBack' AS basewizardcommandbutton WITH ;
		Caption = "< Back", ;
		Left = 225, ;
		Name = "cmdBack", ;
		TabIndex = 5, ;
		Top = 325
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdCancel' AS basewizardcommandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Left = 100, ;
		Name = "cmdCancel", ;
		TabIndex = 4, ;
		Top = 325
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdFinish' AS basewizardcommandbutton WITH ;
		Caption = "Finish", ;
		Left = 425, ;
		Name = "cmdFinish", ;
		TabIndex = 7, ;
		Top = 325
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdHelp' AS basewizardcommandbutton WITH ;
		Caption = "Help", ;
		Left = 10, ;
		Name = "cmdHelp", ;
		TabIndex = 3, ;
		Top = 325
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdNext' AS basewizardcommandbutton WITH ;
		Caption = "Next >", ;
		Left = 315, ;
		Name = "cmdNext", ;
		TabIndex = 6, ;
		Top = 325
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfWizard' AS basewizardpageframe WITH ;
		ErasePage = .T., ;
		Height = 364, ;
		Name = "pgfWizard", ;
		TabIndex = 1, ;
		Top = 0, ;
		Width = 519, ;
		BASEPAGE1.Name = "BASEPAGE1"
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="pageframe" />

	ADD OBJECT 'shpSeparator' AS basewizardshape WITH ;
		Height = 2, ;
		Left = 10, ;
		Name = "shpSeparator", ;
		SpecialEffect = 0, ;
		Top = 310, ;
		Width = 499
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="shape" />
	
	PROCEDURE Activate
		* If we're not being released, select the first step when the form is first
		* displayed. Then refresh the steps.
		
		with This
			if not .lRelease
				if .nCurrentStep = 0
					.SelectStep(1)
				endif .nCurrentStep = 0
				.RefreshSteps()
				dodefault()
			endif not .lRelease
		endwith
		
	ENDPROC

	PROCEDURE cancel		&& Reverts in all open work areas
		* Rollback all changes.
		
		local laCursors[1], ;
			lnI, ;
			lcCursor
		for lnI = 1 to aused(laCursors)
			lcCursor = laCursors[lnI, 1]
			if cursorgetprop('Buffering', lcCursor) > 1
				tablerevert(.T., lcCursor)
			endif cursorgetprop('Buffering', lcCursor) > 1
		next lnI
		This.lCancel = .T.
		
	ENDPROC

	PROCEDURE Destroy
		with This
		
		* Revert any unsaved records.
		
			if not .lCancel
				.Cancel()
			endif not .lCancel
		
		* Restore the saved help setting and file.
		
			.RestoreHelp()
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE finish		&& An abstract method to do the "finish" tasks
		* Do something, then release the form.
		
		This.Release()
		
	ENDPROC

	PROCEDURE GotFocus
		* Only do the default behavior if this isn't the first time called.
		
		if This.nFormerStep > 0
			dodefault()
		endif This.nFormerStep > 0
		
	ENDPROC

	PROCEDURE Init
		local lnI
		dodefault()
		with This
		
		* Ensure the developer set the nMaxSteps property and added as many pages to
		* the pageframe as we have steps.
		
			assert .nMaxSteps > 0 ;
				message 'Set nMaxSteps to a valid value'
			assert .pgfWizard.PageCount = .nMaxSteps ;
				message "nMaxSteps doesn't match pgfWizard.PageCount"
		
		* Dimension the aSteps array, then populate it with the steps for this wizard.
		
			dimension .aSteps[.nMaxSteps, 5]
			.aSteps = ''
			for lnI = 1 to .nMaxSteps
				.aSteps[lnI, 2] = '.T.'
				.aSteps[lnI, 3] = .F.
				.aSteps[lnI, 4] = .T.
				.aSteps[lnI, 5] = 0
			next lnI
			.SetupSteps()
		endwith
		
	ENDPROC

	PROCEDURE isstepenabled		&& Determines if a step is enabled
		lparameters tnStep
		local luEnabled, ;
			llReturn
		with This
			luEnabled = .aSteps[tnStep, 4]
			llReturn  = iif(vartype(luEnabled) = 'C', evaluate(luEnabled), luEnabled)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		do case
		
		* Page up.
		
			case tnKeyCode = 18 and This.nCurrentStep > 1
				if This.ValidateCurrentControl()
					This.cmdBack.Click()
				endif This.ValidateCurrentControl()
		
		* Page down.
		
			case tnKeyCode = 3 and This.nCurrentStep < This.nMaxSteps
				if This.ValidateCurrentControl()
					This.cmdNext.Click()
				endif This.ValidateCurrentControl()
		
		* Any other key.
		
			otherwise
				dodefault(tnKeyCode, tnShiftAltCtrl)
		endcase
		
	ENDPROC

	PROCEDURE Load
		* Dimension the aSteps array.
		
		dodefault()
		dimension This.aSteps[1, 4]
		
	ENDPROC

	PROCEDURE loadstepscombo		&& Loads the Steps combobox
		* Load the steps combobox with only those steps that are enabled.
		
		local lnStep, ;
			lcRowSource, ;
			lnItem, ;
			lnI
		with This.cboSteps
			lnStep      = .Value
			lcRowSource = ''
			lnItem      = 0
			for lnI = 1 to This.nMaxSteps
				if This.IsStepEnabled(lnI)
					lnItem      = lnItem + 1
					lcRowSource = lcRowSource + iif(lnItem = 1, '', ',') + ;
						This.aSteps[lnI, 1]
					dimension .aItems[lnItem]
					.aItems[lnItem] = lnI
				endif This.IsStepEnabled(lnI)
			next lnI
			.RowSource = lcRowSource
			.Requery()
			.Value = lnStep
		endwith
		
	ENDPROC

	PROCEDURE QueryUnload
		* If the user clicked on the Close box, let's cancel the wizard.
		
		This.Cancel()
		
	ENDPROC

	PROCEDURE refreshsteps		&& Set the "step complete" flags in the aSteps array
		local llOK, ;
			lnSteps, ;
			lnI, ;
			lcPrompt, ;
			lcRule, ;
			lnPage, ;
			loControl
		with This
		
		* Lock the screen.
		
			.LockScreen = .T.
		
		* Set the "step complete" flags in the aSteps array.
		
			if not empty(.aSteps[1, 1])
				llOK    = .T.
				lnSteps = alen(.aSteps, 1) + 1
				for lnI = 2 to lnSteps
					lcPrompt = iif(lnI = lnSteps, '', .aSteps[lnI, 1])
					lcRule   = .aSteps[lnI - 1, 2]
					lnPage   = .pgfWizard.GetPageNumber(lnI - 1)
					with .pgfWizard.Pages[lnPage]
						llOK = llOK and evaluate(lcRule)
					endwith
					.aSteps[lnI - 1, 3] = llOK
					do case
						case lnI = lnSteps
						case left(lcPrompt, 1) = '\' and llOK
							.aSteps[lnI, 1] = substr(lcPrompt, 2)
						case left(lcPrompt, 1) <> '\' and not llOK
							.aSteps[lnI, 1] = '\' + lcPrompt
					endcase
				next lnI
		
		* Refresh all controls that need refreshing.
		
				for each loControl in .Controls
					do case
						case lower(loControl.Class) = 'basewizardpageframe'
							loControl.RefreshSteps()
						case type('loControl.lRefreshSteps') = 'L' and ;
							loControl.lRefreshSteps
							loControl.Refresh()
						case pemstatus(loControl, 'Refresh', 5)
							loControl.Refresh()
					endcase
				next loControl
		
		* Reload the steps combo.
		
				.LoadStepsCombo()
			endif not empty(.aSteps[1, 1])
		
		* Unlock the screen.
		
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE restorehelp		&& Restores the save help setting and file
		* Restore the saved help setting and file.
		
		with This
			if not empty(.cCurrHelpFile) and file(.cCurrHelpFile)
				set help to (.cCurrHelpFile)
				if .cCurrHelp = 'OFF'
					set help off
				else
					set help on
				endif .cCurrHelp = 'OFF'
			endif not empty(.cCurrHelpFile) ...
		endwith
		
	ENDPROC

	PROCEDURE save		&& Saves in all open work areas
		* Saves in all open work areas.
		
		local llSuccess, ;
			lnI, ;
			laCursors[1], ;
			lcCursor
		llSuccess = .T.
		begin transaction
		for lnI = 1 to aused(laCursors)
			lcCursor = laCursors[lnI, 1]
			if cursorgetprop('Buffering', lcCursor) > 1
				llSuccess = tableupdate(2, .F., lcCursor)
			endif cursorgetprop('Buffering', lcCursor) > 1
			if not llSuccess
				exit
			endif not llSuccess
		next lnI
		if llSuccess
			end transaction
		else
			rollback
		endif llSuccess
		return llSuccess
		
	ENDPROC

	PROCEDURE selectstep		&& Select a particular step
		* Select a particular step.
		
		lparameters tnStep
		local llReturn, ;
			lnStep
		with This
		
		* Ensure tnStep is a valid value.
		
			assert between(tnStep, 1, .nMaxSteps) ;
				message 'Invalid step passed to SelectStep'
		
		* If we're moving to a previous step or the desired step is accessible, see if
		* we can finish the current step (StepDone is an abstract method; the developer
		* will put in custom code that returns .T. to allow leaving the step or .F. to
		* prevent it). Move to the next enabled step, skipping any that are disabled.
		* If everything is OK, move to the desired step and fire an abstract
		* StepSelected method, where the user can put custom code.
		
			if (tnStep < .nCurrentStep or .nCurrentStep = 0 or ;
				(tnStep > 1 and .aSteps[tnStep - 1, 3])) and .StepDone(.nCurrentStep)
				.nFormerStep = .nCurrentStep
				do case
					case .IsStepEnabled(tnStep)
						.nCurrentStep = tnStep
						llReturn = .T.
					case tnStep > .nFormerStep
						lnStep = tnStep + 1
						do while not .IsStepEnabled(lnStep) and lnStep < .nMaxSteps
							lnStep = lnStep + 1
						enddo while not .IsStepEnabled(lnStep) ...
						llReturn = .IsStepEnabled(lnStep)
						if llReturn
							.nCurrentStep = lnStep 
						endif llReturn
					otherwise
						lnStep = tnStep - 1
						do while not .IsStepEnabled(lnStep) and lnStep > 1
							lnStep = lnStep - 1
						enddo while not .IsStepEnabled(lnStep) ...
						llReturn = .IsStepEnabled(lnStep)
						if llReturn
							.nCurrentStep = lnStep 
						endif llReturn
				endcase
				if llReturn and .nFormerStep <> 0
					.StepSelected(.nCurrentStep)
					.RefreshForm()
				endif llReturn ...
			else
				llReturn = .F.
			endif tnStep <= .nCurrentStep ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE sethelp		&& Sets up the help system
		* If a help file is specified, save the current one and use the specified one.
		
		with This
			if not empty(.cHelpFile) and file(.cHelpFile)
				.cCurrHelp     = set('HELP')
				.cCurrHelpFile = set('HELP', 1)
				set help to (.cHelpFile)
				set help on
			endif not empty(.cHelpFile) ...
		endwith
		
	ENDPROC

	PROCEDURE setupsteps		&& Abstract method to initialize the aSteps array
	ENDPROC

	PROCEDURE Show
		lparameters tnStyle
		with This
		
		* Set up the help file.
		
			.SetHelp()
		
		* Make the form the same width as the pageframe (in the designer, the form is
		* sized larger than the pageframe to make it easier to select the form itself).
		
			.MinWidth = min(.MinWidth, .pgfWizard.Width)
			.Width    = .pgfWizard.Width
		
		* Manually call Resize because that method doesn't fire until the form is
		* visible and we may have some controls (such as a status bar) bound to it.
		
			.Resize()
		endwith
		dodefault(tnStyle)
		
	ENDPROC

	PROCEDURE stepdone		&& Abstract method called when a step is complete
		* Developer can hook when steps are completed.
		
		lparameters tnStep
		
	ENDPROC

	PROCEDURE stepselected		&& Abstract method called when a step is selected
		* Developer can hook when steps are selected.
		
		lparameters tnStep
		
	ENDPROC

	PROCEDURE validatecurrentcontrol		&& Ensures the current control's value is valid
		local llValid, ;
			luValid, ;
			loObject
		llValid = .T.
		if type('This.ActiveControl.Name') = 'C'
			loObject = This.ActiveControl
			if pemstatus(loObject, 'Valid', 5)
				luValid = loObject.Valid()
				llValid = vartype(luValid) = 'L' and luValid
			endif pemstatus(loObject, 'Valid', 5)
			if llValid
				loObject.LostFocus()
			endif llValid
		endif type('This.ActiveControl.Name') = 'C' ...
		return llValid
		
	ENDPROC

	PROCEDURE cboSteps.InteractiveChange
		* Select the chosen step if it's accessible.
		
		local lnStep
		with This
			lnStep = .aItems[.Value]
			if left(Thisform.aSteps[lnStep, 1], 1) = '\'
				.Refresh()
			else
				Thisform.SelectStep(lnStep)
			endif left(Thisform.aSteps[lnStep, 1], 1) = '\'
		endwith
		
	ENDPROC

	PROCEDURE cboSteps.Refresh
		* Display the current step.
		
		local lnStep, ;
			lnI
		with This
			lnStep = max(Thisform.nCurrentStep, 1)
			for lnI = 1 to .ListCount
				if .aItems[lnI] = lnStep
					.Value = lnI
				endif .aItems[lnI] = lnStep
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE cmdBack.Click
		* Move to the previous step.
		
		Thisform.SelectStep(Thisform.nCurrentStep - 1)
		
	ENDPROC

	PROCEDURE cmdBack.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('CMD_CAP_BACK')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdBack.Refresh
		* Enable this button if we're not on step 1 and we have any enabled steps to go
		* to.
		
		local lnI, ;
			llNextPage
		with Thisform
			for lnI = 1 to .nCurrentStep - 1
				llNextPage = .IsStepEnabled(lnI)
				if llNextPage
					exit
				endif llNextPage
			next lnI
			This.Enabled = .nCurrentStep > 1 and llNextPage
			This.Visible = .nCurrentStep > 1
		endwith
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		* Cancel all changes, then release the form.
		
		with Thisform
			.Cancel()
			.Release()
		endwith
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('UI_CMD_CANCEL_LOC')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdFinish.Click
		* Call the Finish() method to finish the wizard's job and set a flag that we
		* did.
		
		with Thisform
			if .nCurrentStep <> .nMaxSteps
				.SelectStep(.nMaxSteps)
			endif .nCurrentStep <> .nMaxSteps
			.lFinish = .Finish()
		endwith
		
	ENDPROC

	PROCEDURE cmdFinish.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('CMD_CAP_FINISH')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdFinish.Refresh
		* Enable this button if the last step is complete.
		
		This.Enabled = Thisform.aSteps[Thisform.nMaxSteps, 3]
		
	ENDPROC

	PROCEDURE cmdHelp.Click
		* Fire off the help for the selected step or for the entire wizard.
		
		local lnTopic
		lnTopic = 0
		with Thisform
			do case
				case .aSteps[.nCurrentStep, 5] <> 0
					lnTopic = .aSteps[.nCurrentStep, 5]
				case .HelpContextID <> 0
					lnTopic = .HelpContextID
			endcase
			if lnTopic <> 0
				help id lnTopic
			else
				help
			endif lnTopic <> 0
		endwith
		
	ENDPROC

	PROCEDURE cmdHelp.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('MENU_HELP')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdHelp.Refresh
		* This button is only visible if it's supposed to be.
		
		This.Visible = not empty(Thisform.cHelpFile) or not empty(set('HELP', 1))
		
	ENDPROC

	PROCEDURE cmdNext.Click
		* Move to the previous step.
		
		Thisform.SelectStep(Thisform.nCurrentStep + 1)
		
	ENDPROC

	PROCEDURE cmdNext.Init
		if type('oLocalizer.Name') = 'C'
			This.Caption = oLocalizer.GetLocalizedString('CMD_CAP_NEXT')
		endif type('oLocalizer.Name') = 'C'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdNext.Refresh
		* Enable this button if the current step is done and we're not on the last
		* step and we have any enabled steps to go to.
		
		local lnI, ;
			llNextPage
		with Thisform
			if .nCurrentStep > 0
				for lnI = .nCurrentStep + 1 to .nMaxSteps
					llNextPage = .IsStepEnabled(lnI)
					if llNextPage
						exit
					endif llNextPage
				next lnI
				This.Enabled = .aSteps[.nCurrentStep, 3] and llNextPage and ;
					.nCurrentStep < .nMaxSteps
				This.Visible = .nCurrentStep < .nMaxSteps
			endif .nCurrentStep > 0
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basewizardimage AS baseimage OF "basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refresh		&& Repaints a Form or control and refreshes any values.
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	*</DefinedPropArrayMethod>

	lrefreshsteps = .F.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	Name = "sfwizardimage"

ENDDEFINE

DEFINE CLASS basewizardlabel AS baselabel OF "basecontrols.vcx" 		&& The base class for Wizard Label objects
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	*</DefinedPropArrayMethod>

	lrefreshsteps = .F.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	Name = "sfwizardlabel"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps" favorites="True"/>
		</VFPData>

ENDDEFINE

DEFINE CLASS basewizardlistbox AS baselistbox OF "basecontrols.vcx" 		&& Base class for Wizard ListBox objects
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refreshsteps		&& Refreshes the wizard form
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
		*p: lrefreshstepsonchange		&& .T. to refresh the Wizard steps when the value is changed
	*</DefinedPropArrayMethod>

	lrefreshsteps = .T.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	lrefreshstepsonchange = .T.		&& .T. to refresh the Wizard steps when the value is changed
	Name = "sfwizardlistbox"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps" favorites="True"/>
		<memberdata name="lrefreshstepsonchange" type="property" display="lRefreshStepsOnChange" favorites="True"/>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		</VFPData>
	
	PROCEDURE InteractiveChange
		dodefault()
		with This
			if .lRefreshStepsOnChange
				.RefreshSteps()
			endif .lRefreshStepsOnChange
		endwith
		
	ENDPROC

	PROCEDURE LostFocus
		* Call This.RefreshSteps if we didn't already.
		
		if not This.lRefreshStepsOnChange
			This.RefreshSteps()
		endif not This.lRefreshStepsOnChange
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		dodefault()
		This.RefreshSteps()
		
	ENDPROC

	PROTECTED PROCEDURE refreshsteps		&& Refreshes the wizard form
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if .lRefreshSteps and lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif .lRefreshSteps ...
		endwith
		if pemstatus(Thisform, 'RefreshSteps', 5)
			Thisform.RefreshSteps()
		else
			Thisform.RefreshForm()
		endif pemstatus(Thisform, 'RefreshSteps', 5)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basewizardoptiongroup AS baseoptiongroup OF "basecontrols.vcx" 		&& Base class for Wizard OptionGroup objects
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refreshsteps		&& Refreshes the wizard form
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	*</DefinedPropArrayMethod>

	lrefreshsteps = .T.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	Name = "sfwizardoptiongroup"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps" favorites="True"/>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		</VFPData>
	BASEOPTIONBUTTON1.Name = "BASEOPTIONBUTTON1"
	BASEOPTIONBUTTON2.Name = "BASEOPTIONBUTTON2"
	
	PROCEDURE InteractiveChange
		dodefault()
		This.RefreshSteps()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		dodefault()
		This.RefreshSteps()
		
	ENDPROC

	PROTECTED PROCEDURE refreshsteps		&& Refreshes the wizard form
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if .lRefreshSteps and lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif .lRefreshSteps ...
		endwith
		if pemstatus(Thisform, 'RefreshSteps', 5)
			Thisform.RefreshSteps()
		else
			Thisform.RefreshForm()
		endif pemstatus(Thisform, 'RefreshSteps', 5)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basewizardpageframe AS basepageframe OF "basecontrols.vcx" 		&& The base class for Wizard PageFrame objects
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refreshsteps		&& Refresh all controls that need refreshing
	*</DefinedPropArrayMethod>

	BorderWidth = 0
	ErasePage = .T.
	Height = 254
	Name = "sfwizardpageframe"
	Tabs = .F.
	Top = 0
	_memberdata = <VFPData>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		</VFPData>
	BASEPAGE1.Name = "BASEPAGE1"
	
	PROCEDURE Refresh
		* Set the current page to the step we're on.
		
		if This.ActivePage <> Thisform.nCurrentStep
			This.ActivePage = Thisform.nCurrentStep
		endif This.ActivePage <> Thisform.nCurrentStep
		
	ENDPROC

	PROCEDURE refreshsteps		&& Refresh all controls that need refreshing
		* Refresh all controls on the current page that need refreshing.
		
		local loControl
		with This
			if .ActivePage > 0
				for each loControl in .Pages[.GetPageNumber(.ActivePage)].Controls
					if (type('loControl.lRefreshSteps') = 'L' and ;
						loControl.lRefreshSteps) or pemstatus(loControl, 'Refresh', 5)
						loControl.Refresh()
					endif (type('loControl.lRefreshSteps') = 'L' ...
				next loControl
			endif .ActivePage > 0
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basewizardshape AS baseshape OF "basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	*</DefinedPropArrayMethod>

	lrefreshsteps = .F.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	Name = "sfwizardshape"

ENDDEFINE

DEFINE CLASS basewizardspinner AS basespinner OF "basecontrols.vcx" 		&& The base class for Wizard Spinner objects
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refreshsteps		&& Refreshes the wizard form
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
		*p: lrefreshstepsonchange		&& .T. to refresh the Wizard steps when the value is changed
	*</DefinedPropArrayMethod>

	lrefreshsteps = .T.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	lrefreshstepsonchange = .T.		&& .T. to refresh the Wizard steps when the value is changed
	Name = "sfwizardspinner"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps" favorites="True"/>
		<memberdata name="lrefreshstepsonchange" type="property" display="lRefreshStepsOnChange" favorites="True"/>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		</VFPData>
	
	PROCEDURE InteractiveChange
		dodefault()
		with This
			if .lRefreshStepsOnChange
				.RefreshSteps()
			endif .lRefreshStepsOnChange
		endwith
		
	ENDPROC

	PROCEDURE LostFocus
		* Call This.RefreshSteps if we didn't already.
		
		if not This.lRefreshStepsOnChange
			This.RefreshSteps()
		endif not This.lRefreshStepsOnChange
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		dodefault()
		This.RefreshSteps()
		
	ENDPROC

	PROTECTED PROCEDURE refreshsteps		&& Refreshes the wizard form
		local lnPos, ;
			lnStart, ;
			lcAlias, ;
			lcField
		with This
			lnPos   = at('.', .ControlSource)
			lnStart = .SelStart
			if .lRefreshSteps and lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif .lRefreshSteps ...
		endwith
		if pemstatus(Thisform, 'RefreshSteps', 5)
			Thisform.RefreshSteps()
		else
			Thisform.RefreshForm()
		endif pemstatus(Thisform, 'RefreshSteps', 5)
		This.SelStart = lnStart
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basewizardtextbox AS basetextbox OF "basecontrols.vcx" 		&& The base class for Wizard TextBox objects
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refreshsteps		&& Refreshes the wizard form
		*p: lrefreshsteps		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
		*p: lrefreshstepsonchange		&& .T. to refresh the Wizard steps when the value is changed
	*</DefinedPropArrayMethod>

	lrefreshsteps = .T.		&& .T. if this object should be refreshed when the WizardForm RefreshSteps method is called
	lrefreshstepsonchange = .T.		&& .T. to refresh the Wizard steps when the value is changed
	Name = "sfwizardtextbox"
	_memberdata = <VFPData>
		<memberdata name="lrefreshsteps" type="property" display="lRefreshSteps" favorites="True"/>
		<memberdata name="lrefreshstepsonchange" type="property" display="lRefreshStepsOnChange" favorites="True"/>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		</VFPData>
	
	PROCEDURE InteractiveChange
		dodefault()
		with This
			if .lRefreshStepsOnChange
				.RefreshSteps()
			endif .lRefreshStepsOnChange
		endwith
		
	ENDPROC

	PROCEDURE LostFocus
		* Call This.RefreshSteps if we didn't already.
		
		if not This.lRefreshStepsOnChange
			This.RefreshSteps()
		endif not This.lRefreshStepsOnChange
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		dodefault()
		This.RefreshSteps()
		
	ENDPROC

	PROTECTED PROCEDURE refreshsteps		&& Refreshes the wizard form
		local lnPos, ;
			lnStart, ;
			lcAlias, ;
			lcField
		with This
			lnPos   = at('.', .ControlSource)
			lnStart = .SelStart
			if .lRefreshSteps and lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif .lRefreshSteps ...
		endwith
		if pemstatus(Thisform, 'RefreshSteps', 5)
			Thisform.RefreshSteps()
		else
			Thisform.RefreshForm()
		endif pemstatus(Thisform, 'RefreshSteps', 5)
		This.SelStart = lnStart
		
	ENDPROC

ENDDEFINE
